var documenterSearchIndex = {"docs":
[{"location":"fittingdata/#Fitting-Data-1","page":"Fitting Data","title":"Fitting Data","text":"","category":"section"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"This page is a tutorial on how to fit viscoelastic models to data using RHEOS. If you want to try out the code below, it can all be run from the Julia REPL but note that importing the data exactly as shown will only work if you are using the 'RHEOS/examples' folder as your working directory as that's where the example data files are stored and the directories used are relative.","category":"page"},{"location":"fittingdata/#Stress/Strain/Time-Data-1","page":"Fitting Data","title":"Stress/Strain/Time Data","text":"","category":"section"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"This section is for standard viscoelastic tensile or compression tests where time, stress and strain data are available.","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"First, we need to load in RHEOS","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"using RHEOS","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"RHEOS has a convenience function for importing data from CSV files. The default column delimiter is ',' but an alternative can be specified as a keyword argument. The row delimiter is a newline character ('\\n'). For standard viscoelastic testing data RHEOS expects either stress, strain and time data, just stress and time, or just strain and time. The order of the columns is specified as the first argument in the function importdata. The second argument is the directory of the file, as shown below.","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"data = importdata([\"stress\",\"strain\", \"time\"], \"DataRelaxation.csv\")","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"Now we have all our data stored in the variable data which is of type RheologyData. (In this tutorial, our data file DataRelaxation.csv is in the same directory as our Julia script so we can just use its relative directory.)","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"Let's fit a Standard Linear Solid viscoelastic model via its relaxation modulus, G, as our data is from a stress relaxation test. The first argument is our data, the second argument tells RHEOS which model to fit and the final argument tells RHEOS whether to fit the model using a relaxation modulus (:G) or creep modulus (:J).","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"fitted_SLS_model = modelfit(data, SLS(), :G)","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"Our first fitted model is not contained in the fitted_SLS_model variable which is an instance of the RheologyModel data type.","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"Next, we'll fit a fractional Standard Linear Solid model (the only difference from the above model is that the dash-pot is replaced by a spring-pot). This time we'll also add upper and lower bounds on the model parameters. This is highly recommended for fractional models in particular as values less than 0 or greater than 1 for the spring-pot parameter are unphysical and can cause errors in the Mittag-Leffler function used.","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"lb = [0.1, 0.01, 0.1, 0.1]\nub = [Inf, 0.99, Inf, Inf]\nfitted_fractSLS_model = modelfit(data, FractionalSLS(), :G; lo=lb, hi=ub)","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"Note the two keyword arguments used – lo and hi for the lower and upper parameter boundaries respectively. The special argument Inf for the three of the parameters' upper bounds represent a type of infinity such that the parameters can be as large as required by the optimisation algorithm.","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"For a full list of keyword arguments and features of the modelfit function, see the relevant part of the API section. Models included in RHEOS are also listed in the API section, and discussed in more detail in the Models section.","category":"page"},{"location":"fittingdata/#G*/ω-Data-1","page":"Fitting Data","title":"G*/ω Data","text":"","category":"section"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"RHEOS can also fit models to dynamic mechanical analysis data from oscillatory tests. The importdata function can again be used here but with the column names Gp for the storage modulus, Gpp for the loss modulus and frequency for the frequency column. RHEOS will detect the frequency string and know to load the data into a RheologyDynamic data type. Assuming RHEOS has already been imported, let's load in our data file:","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"data = importdata([\"Gp\",\"Gpp\", \"Frequency\"], \"FrequencyData.csv\")","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"As this is dynamic mechanical testing data it is an instance of the RheologyDynamic data type. As before, we'll try and fit the data to a Standard Linear Solid model – but this time we need to use the dynamicmodelfit function.","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"fitted_SLS_model = dynamicmodelfit(data, SLS())","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"Note that we do not have to specify whether we are fitting via the creep or relaxation modulus as RHEOS always fits dynamic data to the complex (dynamic) modulus. Let's also try to fit the data to a fractional Standard Linear Solid model:","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"lb = [0.1, 0.01, 0.1, 0.1]\nub = [Inf, 0.99, Inf, Inf]\nfitted_fractSLS_model = dynamicmodelfit(data, FractionalSLS(); lo=lb, hi=ub)","category":"page"},{"location":"fittingdata/#","page":"Fitting Data","title":"Fitting Data","text":"For more information on the dynamicmodelfit function, see the API section.","category":"page"},{"location":"samplingandfiltering/#Sampling-and-Filtering-1","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"","category":"section"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"RHEOS offers several functions for sampling and filtering; this page is intended to be a brief tutorial of their use. For detailed descriptions of functions and their optional arguments, see the API section. This section uses some of the data generation functions discussed in more detail in the Generating Data section.","category":"page"},{"location":"samplingandfiltering/#Downsampling-1","page":"Sampling and Filtering","title":"Downsampling","text":"","category":"section"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"To simply downsample data by taking every nth sample, the downsample function can be used. In the below example, every 2nd element is taken.","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"foo = stepgen(10, 5)\n\nbar = downsample(foo, [0.0, 10.0], [2])","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"(Image: downsample1)","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"More than 1 section of downsampling can be defined. For example, the below code takes every 2nd element from time=0.0 seconds to time=5.0 seconds and after that it takes every element. Note that as there are now two different sample rates, the data set is considered as having 'variable' sampling by RHEOS which adds a computational cost to fitting operations.","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"foo = stepgen(10, 5)\n\nbar = downsample(foo, [0.0, 5.0, 10.0], [2, 1])","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"(Image: downsample2)","category":"page"},{"location":"samplingandfiltering/#Upsampling-and-Downsampling-1","page":"Sampling and Filtering","title":"Upsampling and Downsampling","text":"","category":"section"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"The fixedresample is similar to the downsample function but also allows for upsampling. The syntax is almost the same but it requires an addition argument to tell RHEOS whether it should upsample or downsample for that section. Below is an example with three distinct sampling regions, the first two regions are downsampled and the third region is upsampled.","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"foo = stepgen(10, 5)\n\nbar = fixedresample(foo, [0.0, 5.0, 8.0, 10.0], [2, 1, 4], [\"down\", \"down\", \"up\"])","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"(Image: fixedresample)","category":"page"},{"location":"samplingandfiltering/#Variable-Resampling-1","page":"Sampling and Filtering","title":"Variable Resampling","text":"","category":"section"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"Although still in a somewhat experimental stage, RHEOS has a variable resampling function, variableresample which attempts to focus the sampled points on regions of rapid change in the 0th, 1st and 2nd derivatives of the data. This may be useful for focusing on the model fits in the most dynamic regions of the data. See below for a minimal example of use and plotted outcome. See the API for more detailed look at function arguments.","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"foo = singen(2, 0.5; stepsize=0.01)\n\nbar = variableresample(foo, :σ, 0.5)","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"(Image: variableresample)","category":"page"},{"location":"samplingandfiltering/#Smoothing-1","page":"Sampling and Filtering","title":"Smoothing","text":"","category":"section"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"Lastly, RHEOS provides a smoothing function, smooth. The first argument is the data to smooth and the second argument is the (very) approximate time scale of smoothing. (It uses Gaussian smoothing and can be thought of as a low pass filter for information occuring on time scales shorter than the 2nd argument). The padding can be changed using a keyword argument if desired, see API and ImageFiltering.jl Documentation for more details. The example below smooths out some noisy data.","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"foo = rampgen(200.0, 0.0, 100.0; stepsize = 0.1) - rampgen(200.0, 100.0, 200.0; stepsize = 0.1)\n\nbar = foo + 0.1*noisegen(200.0; stepsize=0.1)\n\nbaz = smooth(bar, 10.0)","category":"page"},{"location":"samplingandfiltering/#","page":"Sampling and Filtering","title":"Sampling and Filtering","text":"(Image: smooth)","category":"page"},{"location":"models/#Models-1","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/#Models-included-in-RHEOS-1","page":"Models","title":"Models included in RHEOS","text":"","category":"section"},{"location":"models/#","page":"Models","title":"Models","text":"Several models (i.e. their relaxation modulus, creep modulus and complex modulus) are implemented in RHEOS. Their constructors are listed below. Note that the params argument is always optional, as represented by their containment in square barckets. If left blank then the model's default parameters are used. Additional models are forthcoming.","category":"page"},{"location":"models/#Elements-1","page":"Models","title":"Elements","text":"","category":"section"},{"location":"models/#","page":"Models","title":"Models","text":"Spring\nDashPot\nSpringPot","category":"page"},{"location":"models/#Maxwell-Type-1","page":"Models","title":"Maxwell Type","text":"","category":"section"},{"location":"models/#","page":"Models","title":"Models","text":"FractionalMaxwell\nFractionalMaxwellSpring\nFractionalMaxwellDashpot\nMaxwell","category":"page"},{"location":"models/#Kelvin-Voigt-Type-1","page":"Models","title":"Kelvin-Voigt Type","text":"","category":"section"},{"location":"models/#","page":"Models","title":"Models","text":"FractionalKelvinVoigt\nFractionalKVspring\nFractionalKVdashpot\nKelvinVoigt","category":"page"},{"location":"models/#Zener-Type-1","page":"Models","title":"Zener Type","text":"","category":"section"},{"location":"models/#","page":"Models","title":"Models","text":"FractionalZener\nFractionalSLS\nFractionalSpecial\nSLS\nSLS2","category":"page"},{"location":"models/#Creating-your-own-model-1","page":"Models","title":"Creating your own model","text":"","category":"section"},{"location":"models/#","page":"Models","title":"Models","text":"If you know some (or all) of the moduli for a model that you would like use but hasn't already been implemented in RHEOS, this section will explain how to quickly import these moduli into a RheologyModel object for use with other parts of RHEOS. For the sake of example, we will use the relaxation modulus, storage modulus and loss modulus of the Standard Linear Solid model as defined in RHEOS.","category":"page"},{"location":"models/#","page":"Models","title":"Models","text":"function G_sls(t::Vector{T}, params::Vector{T}) where T<:Real\n    η, kᵦ, kᵧ = params\n\n    G = kᵧ .+ kᵦ*exp.(-t*kᵦ/η)\nend\n\nfunction Gp_sls(ω::Vector{T}, params::Vector{T}) where T<:Real\n    η, kᵦ, kᵧ = params\n\n    τ = η/kᵦ\n\n    denominator = 1 .+ (τ^2)*(ω.^2)\n    numerator = (ω.^2)*(τ^2)*kᵦ\n\n    Gp = numerator./denominator .+ kᵧ\nend\n\nfunction Gpp_sls(ω::{T}, params::Vector{T}) where T<:Real\n    η, kᵦ, kᵧ = params\n\n    τ = η/kᵦ\n\n    denominator = 1 .+ (τ^2)*(ω.^2)\n    numerator = ω*τ*kᵦ\n\n    Gpp = numerator./denominator\nend","category":"page"},{"location":"models/#","page":"Models","title":"Models","text":"Now we have the our moduli defined as Julia functions we can store them, along with some (optional) default parameters, in a RheologyModel struct in the following way.","category":"page"},{"location":"models/#","page":"Models","title":"Models","text":"our_model = RheologyModel(G = G_sls, Gp = Gp_sls, Gpp = Gpp_sls, params = [1.0, 0.5, 1.0])","category":"page"},{"location":"models/#","page":"Models","title":"Models","text":"Now we can fit this model to data and use it to make predictions. Any moduli not included in this final step will default to a null_modulus which always returns the array [-1.0].","category":"page"},{"location":"fileIO/#File-I/O-1","page":"File I/O","title":"File I/O","text":"","category":"section"},{"location":"fileIO/#CSV-Import/Export-1","page":"File I/O","title":"CSV Import/Export","text":"","category":"section"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"In the Fitting Data section we saw how to import data from csv files. As a brief overview of that functionality, the 3 lines below demonstrate how to import stress/strain/time data, partial strain/time data, and G'/G''/frequency data. The columns can be in any order but need to specified by the first argument array of strings shown below. Note that if you want to try and run this code exactly as shown below, the data files used in these examples are stored in the 'RHEOS/examples' directory.","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"data = importdata([\"stress\",\"strain\", \"time\"], \"DataRelaxation.csv\")\n\ndata_incomplete = importdata([\"strain\", \"time\"], \"DataIncomplete.csv\")\n\ndata_dynamic = importdata([\"Gp\",\"Gpp\", \"Frequency\"], \"FrequencyData.csv\")","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"Where the first two function calls return RheologyData objects and the last function call returns a RheologyDynamic object.","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"If you want to analyse or plot your data in software other than Julia you will likely want to export it to a CSV file. To export RheologyData and RheologyDynamic objects to CSV files we can use the exportdata function. For the two complete data-sets we imported above, we can export them into new files in the following way.","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"exportdata(data, \"exported_data\")\n\nexportdata(data_dynamic, \"exported_dynamic_data\")","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"The '.csv' extension will automatically be added (and can be modified if needs be through use of a keyword argument). The delimiter can also be changed if necessary. See API section for information on this.","category":"page"},{"location":"fileIO/#Native-Julia-data-files-(JLD2)-1","page":"File I/O","title":"Native Julia data files (JLD2)","text":"","category":"section"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"When using RHEOS and doing all subsequent analysis and plotting in Julia, it is convenient to be able to store native Julia objects to disk so that they can be loaded in to subsequent Julia sessions. RHEOS provides two pairs of convenience functions to facilitate this: savedata and loaddata, savemodel and loadmodel. Using our data imported above we can demonstrate saving and loading data (it is exactly the same process for both RHEOS data types).","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"savedata(data, \"imported_data\")\n\nloaded_data = loaddata(\"imported_data.jld2\")","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"The savedata function will automatically append a '.jld2' to the filename when saving but this can be modified if necessary through a keyword argument. savedata and loaddata work on both RheologyData and  RheologyDynamic objects.","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"Lastly, let's create a Standard Linear Solid model object with default parameters, save that to disk and load it again.","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"model = SLS()\n\nsavemodel(model, \"saved_model\")\n\nloaded_model = loadmodel(\"saved_model.jld2\")","category":"page"},{"location":"fileIO/#Custom-formatted-Data-Import-1","page":"File I/O","title":"Custom-formatted Data Import","text":"","category":"section"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"If your data doesn't fit into the CSV format required by importdata and you don't want to reformat it, you may want to write your own code to load the data into your Julia session. Once you have the data, you can simply call the appropriate RheologyData outer constructor as follows:","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"data = RheologyData(σ, ϵ, t)","category":"page"},{"location":"fileIO/#","page":"File I/O","title":"File I/O","text":"where σ, ϵ and t are arrays of a Real subtype that you must provide.","category":"page"},{"location":"moreexamples/#More-Examples-1","page":"More Examples","title":"More Examples","text":"","category":"section"},{"location":"moreexamples/#","page":"More Examples","title":"More Examples","text":"The following examples combine multiple elements of RHEOS into scripts which are likely to resemble common workflows. In addition to RHEOS, some of them use the PyPlot package for plotting. All of the examples below are also stored in the RHEOS directory in the 'examples' folder.","category":"page"},{"location":"predictingresponse/#Predicting-Responses-1","page":"Predicting Responses","title":"Predicting Responses","text":"","category":"section"},{"location":"predictingresponse/#Stress/Strain/Time-Data-1","page":"Predicting Responses","title":"Stress/Strain/Time Data","text":"","category":"section"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"Now that we know how to import datasets and fit models to them, let's try and make some predictions based on fitted model parameters. We will use our data imported and models fitted_SLS_model and fitted_fractSLS_model as fitted in the previous section. First we'll use model prediction to see how well the models were fitted to the relaxation data.","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"SLS_predicted = modelpredict(data, fitted_SLS_model, :G)\n\nfractSLS_predicted = modelpredict(data, fitted_fractSLS_model, :G)","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"Now we have the predicted data, we can plot. Any plotting library can be used but the example code below uses the PyPlot Julia package.","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"using PyPlot\n\nfig, ax = subplots()\nax[:plot](data.t, data.σ, label=\"Data\", color=\"black\")\nax[:plot](SLS_predicted.t, SLS_predicted.σ, label=\"SLS\")\nax[:plot](fractSLS_predicted.t, fractSLS_predicted.σ, \"--\", label=\"Fractional SLS\")\nax[:legend](loc=\"best\")\nshow()","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"(Image: relaxation prediction) ","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"We can see from the above plot that the fractional Standard Linear Solid model has yielded a much better fit than that regular Standard Linear Solid. Now we also have creep data generated using the same model. Let's see how well our fitted models perform making predictions on a completely different type of data.","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"creep_data = importdata([\"stress\", \"strain\", \"time\"], \"DataCreep.csv\")\n\ncreep_SLS_predicted = modelpredict(creep_data, fitted_SLS_model, :J)\n\ncreep_fractSLS_predicted = modelpredict(creep_data, fitted_fractSLS_model, :J)","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"Note the two differences in the modelpredict function calls. In the first argument we are predicting based on the creep data so we use the creep data we imported in the first line of the above code block. In the third argument we use the argument :J instead of :G to make predictions based on the creep modulus, not the relaxation modulus as before. Plotting the above but strain this time not stress as it's using the creep modulus:","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"fig, ax = subplots()\nax[:plot](creep_data.t, creep_data.ϵ, label=\"Creep Data\", color=\"black\")\nax[:plot](creep_SLS_predicted.t, creep_SLS_predicted.ϵ, label=\"SLS\")\nax[:plot](creep_fractSLS_predicted.t, creep_fractSLS_predicted.ϵ, \"--\", label=\"Fractional SLS\")\nax[:legend](loc=\"best\")\nshow()","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"(Image: creep prediction)","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"Again we see that the fractional SLS model has yielded a far better prediction, even on data not seen during the fitting stage.","category":"page"},{"location":"predictingresponse/#Frequency-Data-1","page":"Predicting Responses","title":"Frequency Data","text":"","category":"section"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"Although it is very similar to the above, for completeness this section demonstrates how to predict frequency-based rheology data.","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"frequency_data = importdata([\"Gp\", \"Gpp\", \"frequency\"], \"FrequencyData.csv\")\n\nfreq_fractSLS_predicted = dynamicmodelpredict(frequency_data, fitted_fractSLS_model)","category":"page"},{"location":"predictingresponse/#","page":"Predicting Responses","title":"Predicting Responses","text":"See the dynamicmodelpredict for more information on the function itself.","category":"page"},{"location":"generatingdata/#Generating-Data-1","page":"Generating Data","title":"Generating Data","text":"","category":"section"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"RHEOS has several convenience functions for generating arbitrarily complex loading patterns. These may be particularly useful for investigating the responses of viscoelastic models with which users are unfamiliar. This section will demonstrate how to use them. ","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"It should be noted at the outset that the way these functions are currently implemented, they generate the same loading in both stress and strain with the expectation that users will then use one or other to make predictions. ","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"As all the structs generated are of RheologyData type, the same addition, subtraction and multiplication overloaded methods can be used for real data. When adding two RheologyData structs and one is longer than the other (in time), the shorter one will be extended by keeping the last values of that shorter struct's data constant for the rest of time. Adding, subtracting and multiplying will raise an error if the data do not have the same sample rate. All plots here are generated using the PyPlot Julia package.","category":"page"},{"location":"generatingdata/#Step,-Ramp-and-Oscillatory-Loading-1","page":"Generating Data","title":"Step, Ramp and Oscillatory Loading","text":"","category":"section"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"The code below uses stepgen to create one step starting at 100 seconds (with total duration of 1000 seconds) and another step starting at 500 seconds lasting the same total duration. The first argument of stepgen determines the total length in seconds. The second step is then subtracted from the first to create a new combined loading pattern as shown in the plots below. ","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"foo = stepgen(1000, 100)\n\nbar = stepgen(1000, 500)\n\nbaz = foo - bar","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"(Image: step gif)","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"The above example uses an 'instantaneous' step. However, a logistic functional transition can be used by adding a non-zero t_trans keyword argument. Next we'll generate ramp loading using rampgen. The arguments in order are the total time length (as before), the time to start the ramp and the time to stop the ramp.","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"foo = rampgen(1000, 100, 200)\n\nbar = rampgen(1000, 500, 700)\n\nbaz = 2*foo - bar","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"(Image: ramp)","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"And finally some oscillatory loading, ramp loading, and oscillatory loading multiplied by the ramp loading. The first argument of singen is the total time length, the second is the frequency in hertz, and the keyword argument is phase in radians.","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"foo = singen(1000, 1/50; phase = -π/2)\n\nbar = rampgen(1000, 10, 400) - rampgen(1000, 400, 800)\n\nbaz = foo*bar","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"(Image: osci)","category":"page"},{"location":"generatingdata/#Repeated-Loading,-Adding-Noise-1","page":"Generating Data","title":"Repeated Loading, Adding Noise","text":"","category":"section"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"For repeated loading, RHEOS provides a convenience function that can loop loading patterns a specified number of times. Similar to the step function, repeatdata also offers a t_trans keyword argument which determines the transition between the end of one loop and the start of the next. If t_trans=0 then the transition is instantaneous, if not the transition occurs by logistic function with approximate transition time t_trans. The repeatdata function currently only works if the stress and strain arrays contain the same data (as is produced by all the data generation functions). Below we use our most recently defined baz variable (the oscillatory loading multiplied by the two ramps) to demonstrate.","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"repeatedbaz = repeatdata(baz, 3)","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"(Image: repeatedbaz)","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"Finally, we can add uniform white noise to the data using the noisegen function. The below example demonstrates this on a simple step.","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"foo = stepgen(100, 50)\nbar = 0.01*noisegen(100)\nbaz = foo + bar","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"(Image: noise)","category":"page"},{"location":"generatingdata/#A-More-Complicated-Example-1","page":"Generating Data","title":"A More Complicated Example","text":"","category":"section"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"Below is an example which uses almost all of the RHEOS data generation functionality together in one example.","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"# generate a single step at 25 seconds\nstepup = stepgen(50.0, 25.0; stepsize = 0.05, t_trans = 2.5)\n\n# generate an oscillation which starts fading in at 25.5 seconds and has faded out by 49.5 seconds\nosci = 0.1*singen(50.0, 0.2; stepsize = 0.05)\nrampup = rampgen(50.0, 25.5, 37.5; stepsize = 0.05)\nrampdown = -rampgen(50.0, 37.5, 49.5; stepsize = 0.05)\n\n# combine the step and faded oscillation\ncombined = osci*(rampup + rampdown) + stepup\n\n# repeat this three times\nrepeated = repeatdata(combined, 3)\n\n# add some white noise with amplitude of 0.01\nnoisyrepeated = repeated + 0.01*noisegen(150.0; seed = 1, stepsize = 0.05)","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"which, when plotted, produces the following: (Image: complicated)","category":"page"},{"location":"generatingdata/#","page":"Generating Data","title":"Generating Data","text":"We can zoom in to a stepped region to see the noise more clearly (Image: complicatedzoom)","category":"page"},{"location":"#RHEOS-RHEology-Open-Source-1","page":"Home","title":"RHEOS - RHEology Open Source","text":"","category":"section"},{"location":"#Please-Note-1","page":"Home","title":"Please Note","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"RHEOS is currently undergoing a major update. The documentation is being updated accordingly. The API section will be the first page to be updated. The tutorials from the previous documentation will be updated after this.","category":"page"},{"location":"#Overview-1","page":"Home","title":"Overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"RHEOS is a software package written in the Julia programming language that provides tools for analyzing rheological data. Features include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Stress/Strain/Time data can be easily be fitted to a viscoelastic model\nG'/G''/Frequency data can easily be fitted to a viscoelastic model\nMany standard and fractional viscoelastic models have already been implemented within RHEOS new ones can easily be added by users\nA fitted model can be used to predict the behaviour of the material under other loading conditions, enabling the fit/predict paradigm of model selection\nArtificial loading conditions can be generated within RHEOS to better understand a model's response","category":"page"},{"location":"#Documentation-1","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The sections in this documentation each aim to provide tutorials in different elements of RHEOS. The API section is a comprehensive list of RHEOS types and functions, and brief descriptions of their use. For corrections or further questions, please create an issue on the Github repository. Note that whenever you restart your Julia session you will have to reload RHEOS by typing using RHEOS, to avoid repetition this line is not included in every piece of example code.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Install Julia, version 1.1.1\nFrom Julia REPL, enter pkg mode by pressing ]\n(Optional) Enable desired Project.toml environment\nRun the command add \"https://github.com/JuliaRheology/RHEOS.jl\"","category":"page"},{"location":"#Included-Dependencies-1","page":"Home","title":"Included Dependencies","text":"","category":"section"},{"location":"#[FastConv.jl](https://github.com/aamini/FastConv.jl)-1","page":"Home","title":"FastConv.jl","text":"","category":"section"},{"location":"#[MittagLeffler.jl](https://github.com/jlapeyre/MittagLeffler.jl)-1","page":"Home","title":"MittagLeffler.jl","text":"","category":"section"},{"location":"#Citation-1","page":"Home","title":"Citation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you use RHEOS in your work, please consider citing the following paper TBA","category":"page"},{"location":"#References-1","page":"Home","title":"References","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"W. N. Findley, J. S. Lai, K. Onaran — Creep and Relaxation of Nonlinear Viscoelastic Materials (with an Introduction to Linear Viscoelasticity), Dover Publications, New York. (1976)\nS. G. Johnson — The NLopt nonlinear-optimization package, http://ab-initio.mit.edu/nlopt\nJ. Bezanson, A. Edelman, S. Karpinski, V. B. Shah — Julia: A Fresh Approach to Numerical Computing, SIAM Review, doi: 10.1137/141000671. (2017)","category":"page"},{"location":"API/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"API/#Sampling-and-Filtering-Functions-1","page":"API","title":"Sampling and Filtering Functions","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"resample\ncutting\nsmooth\nextract","category":"page"},{"location":"API/#RHEOS.resample","page":"API","title":"RHEOS.resample","text":"resample(self::RheoTimeData, elperiods::Union{Vector{K}, K}; time_boundaries::Union{Nothing, Vector{T}} = nothing)\n\nResample data with new sample rate(s).\n\nResample can downsample or upsample data. If the number of elperiods is negative it is going to reduce the number of samples, viceversa if it is positive. If time boundaries are not specified, resampling is applied to the whole set of data. If number of elements per period (elperiods) is 1 or -1 it returns the original RheoTimeData, whilst 0 is not accepted as a valid argument for elperiods.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.cutting","page":"API","title":"RHEOS.cutting","text":"cutting(self::RheoTimeData, time_on::T1, time_off::T2) where {T1<:Number, T2<:Number}\n\nRemove the data outside a specified time interval.\n\nBy specifing a time interval (timeon, timeoff), a new RheoTimeData is returned without the data lying outside time interval.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.smooth","page":"API","title":"RHEOS.smooth","text":"smooth(self::RheoTimeData, τ::Real; pad::String=\"reflect\")\n\nSmooth data using a Gaussian Kernel to time scale τ (approximately half power).\n\nSmooths both σ and ϵ. Essentially a low pass filter with frequencies of 1/τ being cut to approximately half power. For other pad types available see ImageFiltering documentation.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.extract","page":"API","title":"RHEOS.extract","text":"extract(self::Union{RheoTimeData,RheoFreqData}, type::Union{TimeDataType,FreqDataType,Integer})\n\nExtract specific fields form RheoTimeData or RheoFreqData.\n\nExtract can copy one or more fields from a given RheoXData variable into a new RheoXData one. The fields that are copied are identified by the specified type of data. If self is a RheoTimeData, the type that can be extracted is timeonly (or 0), stressonly (or 1), strainonly (or 2). Note that strainandstress (or 3) is not allowed. If self is a RheoFreqData, the type that can be extracted is freconly (or 0).\n\n\n\n\n\n","category":"function"},{"location":"API/#Fitting-and-Predicting-Functions-1","page":"API","title":"Fitting and Predicting Functions","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"modelfit\nmodelpredict\nmodelstepfit\nmodelsteppredict\ndynamicmodelfit\ndynamicmodelpredict","category":"page"},{"location":"API/#RHEOS.modelfit","page":"API","title":"RHEOS.modelfit","text":"modelfit(data::RheoTimeData, model::RheoModelClass, modloading::Symbol; p0::Union{NamedTuple,Tuple} = (), lo::Union{NamedTuple,Tuple} = (), hi::Union{NamedTuple,Tuple} = (), verbose::Bool = false, rel_tol = 1e-4, diff_method=\"BD\")\n\nFit RheologyData struct to model and return a fitted model as a RheologyModel object.\n\nArguments\n\ndata: RheoTimeData struct containing all data\nmodel: RheoModelClass containing moduli functions and named tuple parameters\nmodloading: strainimposed or 1, stressimposed or 2\np0: Initial parameters to use in fit (uses 0.5 for all parameters if not defined)\nlo: Lower bounds for parameters\nhi: Upper bounds for parameters\nverbose: If true, prints parameters on each optimisation iteration\nrel_tol: Relative tolerance of optimization, see NLOpt docs for more details\ndiff_method: Set finite difference formula to use for derivative, currently \"BD\" or \"CD\"\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.modelpredict","page":"API","title":"RHEOS.modelpredict","text":"modelpredict(data::RheoTimeData,model::RheoModel; diff_method=\"BD\")\n\nGiven an incomplete data set (only either stress or strain missing) and model with values substituted into parameters (RheoModel),return a new dataset based on the model. If data is type of stressonly, then creep modulus (:J) is used; if data type is strainonly relaxation modulus (:G). A complete RheoTimeDatadata of type \"strainandstress\" is returned. 'diff_method' sets finite difference for calculating the derivative used in the hereditary integral and can be either backwards difference (\"BD\") or central difference (\"CD\").\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.modelstepfit","page":"API","title":"RHEOS.modelstepfit","text":"modelstepfit(data::RheoTimeData, model::RheoModelClass, modloading::Union{LoadingType,Integer}; step=nothing, p0::Union{NamedTuple,Tuple} = (), lo::Union{NamedTuple,Tuple} = (), hi::Union{NamedTuple,Tuple} = (), verbose::Bool = false, rel_tol = 1e-4) where T<:Real\n\nSame as 'modelfit' except assumes a step loading. If this assumption is appropriate for the data then fitting can be sped up greatly by use of this function. If modloading is strainimposed, relaxation modulus is used, then the element in the middle of the strain is assumed to be the amplitude of the step. If modloading is stressimposed, the creep modulus is used, then the middle element of the stress is assumed to be the amplitude of the step. Alternatively, it is possible to define the value of the step by defining the optional \"step\" parameter.\n\nArguments\n\ndata: RheoTimeData struct containing all data\nmodel: RheoModelClass containing moduli and parameters tuples\nmodloading: strainimposed for relaxation modulus, stressimposed for creep modulus\np0: Named tuple of initial parameters to use in fit (uses 0.5 for all parameters if none given)\nlo: Named tuple of lower bounds for parameters\nhi: Named tuple of upper bounds for parameters\nverbose: If true, prints parameters on each optimisation iteration\nrel_tol: Relative tolerance of optimization, see NLOpt docs for more details\ndiff_method: Set finite difference formula to use for derivative, currently \"BD\" or \"CD\"\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.modelsteppredict","page":"API","title":"RHEOS.modelsteppredict","text":"modelsteppredict(data::RheoTimeData, model::RheoModel; step_on::Real = 0.0, diff_method = \"BD\")\n\nSame as modelpredict but assumes a step loading with step starting at 'step_on'. Singularities are bypassed by adding 1 to the index of the singular element.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.dynamicmodelfit","page":"API","title":"RHEOS.dynamicmodelfit","text":"dynamicmodelfit(data::RheoFreqData, model::RheoModelClass; p0::Union{NamedTuple,Tuple} = (), lo::Union{NamedTuple,Tuple} = (), hi::Union{NamedTuple,Tuple} = (), verbose::Bool = false, rel_tol = 1e-4) where T<:Real\n\nFits model to the frequency/loss+storage moduli data.\n\nAll arguments are as described below. As this fitting procedure is fitting two functions simultaneously (the storage and loss moduli), if left untransformed the fit would tend to favour the modulus which is larger in magnitude and not fit the other modulus well. To avoid this, RHEOS offers a number of data transforms which can be used by changing \"weights\" argument.\n\nArguments\n\ndata: RheoFreqData struct containing all data\nmodel: RheoModelClass containing moduli and symbols of parameters\np0: Initial parameters to use in fit (uses 0.5 for all parameters if none given)\nlo: Lower bounds for parameters\nhi: Upper bounds for parameters\nverbose: If true, prints parameters on each optimisation iteration\nrel_tol: Relative tolerance of optimization, see NLOpt docs for more details\nweights: Weighting mode for storage and loss modulus (linear, log, global)\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.dynamicmodelpredict","page":"API","title":"RHEOS.dynamicmodelpredict","text":"dynamicmodelpredict(data::RheoFreqData, model::RheoModel)\n\nGiven dynamic rheology data with only frequency and model where parameters have been substituted. Returns another RheoFreqData instance with the predicted Gp and Gpp based on the frequencies and model given as arguments.\n\n\n\n\n\n","category":"function"},{"location":"API/#Data-Generation-Functions-1","page":"API","title":"Data Generation Functions","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"timeline\nstrainfunction\nstressfunction\nhstep\nramp\nstairs\nsquare\nsawtooth\ntriangle\nfrequencyspec","category":"page"},{"location":"API/#RHEOS.timeline","page":"API","title":"RHEOS.timeline","text":"timeline(;t_start::Real=0., t_end::Real=10., step::Real=(t_end - t_start)/250.)\n\nGenerate RheoTimeData struct with only the time data.\n\nArguments\n\nt_start: Starting time, typically 0\nt_end: End time\nstep: Time between sample\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.strainfunction","page":"API","title":"RHEOS.strainfunction","text":"strainfunction(data::RheoTimeData, f::T) where T<:Function\n\nAccepts a RheoTimeData and outputs a new RheoTimeData with a strain imposed. The strain signal is determined by the function provided, which should take time as its only argument. The original data's time signal is used.\n\nNormally used with a RheoTimeData generated using the timeline function.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.stressfunction","page":"API","title":"RHEOS.stressfunction","text":"stressfunction(data::RheoTimeData, f::T) where T<:Function\n\nAccepts a RheoTimeData and outputs a new RheoTimeData with a stress imposed. The stress signal is determined by the function provided, which should take time as its only argument. The original data's time signal is used.\n\nNormally used with a RheoTimeData generated using the timeline function.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.hstep","page":"API","title":"RHEOS.hstep","text":"hstep(t; offset=0., amp=1.)\n\nStep generation function for use with stressfunction or strainfunction. offset keyword arguent determines start of step. amp argument determines amplitude (height) of step.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.ramp","page":"API","title":"RHEOS.ramp","text":"ramp(t; offset=0., gradient=1.)\n\nRamp signal generation function for use with stressfunction or strainfunction. offset keyword arguent determines start of ramp. gradient argument determines the linear gradient of the ramp.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.stairs","page":"API","title":"RHEOS.stairs","text":"stairs(t; offset=0., amp=1., width=1.)\n\nStairs signal generation function for use with stressfunction or strainfunction. Equivalent to additional steps being added every width seconds. offset keyword arguent determines start of stairs signal. amp argument determines the height of each additional step.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.square","page":"API","title":"RHEOS.square","text":"square(t; offset=0., amp=1., period=1., width=0.5*period)\n\nSquare signal generation function for use with stressfunction or strainfunction. offset keyword arguent determines start of square signal. amp argument determines the height of each square pulse. period determines the period of one off/on section of the square wave signal. width determines the width of each square pulse.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.sawtooth","page":"API","title":"RHEOS.sawtooth","text":"sawtooth(t; offset=0., amp=1., period=1.)\n\nSawtooth signal generation function for use with stressfunction or strainfunction. offset keyword arguent determines start of sawtooth signal. amp argument determines the height of each sawtooth pulse. period determines the period of the sawtooth wave signal.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.triangle","page":"API","title":"RHEOS.triangle","text":"triangle(t; offset=0., amp=1., period=1.)\n\nTriangle signal generation function for use with stressfunction or strainfunction. offset keyword arguent determines start of triangle signal. amp argument determines the height of each triangle pulse. period determines the period of the triangle wave signal. width determines the width of the triangles.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.frequencyspec","page":"API","title":"RHEOS.frequencyspec","text":"frequencyspec(;ω_start::Real=1.0e-2, ω_end::Real=1.0e2, step::Real=(ω_end-ω_start)/1.0e5)\n\nGenerate RheoFreqData struct with only the frequency data.\n\nArguments\n\nω_start: Starting time, typically 0\nω_end: End time\nstep: Step between frequencies\n\n\n\n\n\n","category":"function"},{"location":"API/#Data-IO-1","page":"API","title":"Data IO","text":"","category":"section"},{"location":"API/#","page":"API","title":"API","text":"importcsv\nexportcsv","category":"page"},{"location":"API/#RHEOS.importcsv","page":"API","title":"RHEOS.importcsv","text":"importcsv(filepath::String; t_col::IntOrNone = nothing, σ_col::IntOrNone = nothing, ϵ_col::IntOrNone = nothing, ω_col::IntOrNone = nothing, Gp_col::IntOrNone = nothing, Gpp_col::IntOrNone = nothing, delimiter=',')\n\nLoad data from a CSV file (two/three columns, comma seperated by default but delimiter can be specified in the delimiter keyword argument). Arguments must be identified by providing the number of the column in which they are contained.\n\nCan be used to construct either a RheoTimeData instance or a RheoFreqData instance. Function detects whether \"time\" or \"frequency\" has been included and proceeds accordingly. For oscillatory data, all three columns (Gp, Gpp, Frequency) must be provided. For regular viscoelastic data only time, or time-stress, or time-strain or time-stress-strain data can be provided.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.exportcsv","page":"API","title":"RHEOS.exportcsv","text":"exportcsv(self::Union{RheoTimeData, RheoFreqData}, filedir::String; delimiter=',', colorder=nothing)\n\nExport RheoTimeData or RheoFreqData type to csv format. May be useful for plotting/analysis in other software. By default, full time data will be exported with columns ordered as (σ, ϵ, t). Partial time data will be ordered as either (σ, t) or (ϵ, t). Full frequency data will be ordered as (Gp, Gpp, ω). The order of columns can be customised by passing a NamedTuple to the colorder arguments. For example (σ = 2, t = 1, ϵ = 3) would export the columns in the order (t, σ, ϵ). As with importcsv, the delimiter can be set by keyword argument.\n\n\n\n\n\n","category":"function"}]
}
